----------MAIN----------
	La inceputul programului am facut o verificare pentru numarul de argumente din linia de comanda. Daca numarul era de 5, atunci programul se ocupa de cerintele c1 si c2, altfel se ocupa de cerinta 3 (-d). Pentru primele doua cerinte am citit si factorul si l-am convertit la valoare intreaga cu ajutorul functiei "atoi", apoi am creat o matrice in care voi copia imaginea din fisierul ".ppm". Matricea este o matrice de culoare, asta insemnand ca fiecare element al matricei este o structura ce contine 3 variabile (R, G, B) ce reprezinta codurile de culoare. Inainte de a citi imaginea am citit antetul fisierului si am retinut tipul imagini(P6), marimea imaginii, valoarea maxima a unei culori(255) si caracterul "\n" pentru a muta cursorul la inceputul imaginii din fisier. Dupa aceea am alocat fiecare rand al matricei de culori si am citit cate un rand de pixeli din imagine, pe care i am retinut pe randul deabia alocat. Dupa citirea imaginii am apelat functia "ConstrArbC" care imi creaza un arbore cuaternar prin divizarea matricei in 4 submatrice (NV, NE, SE, SV), repetand acest proces pana cand scorul similaritatii dintr-o submatrice este mai mic decat factorul dat, caz in care retin culorile din acel bloc in noduri terminale. Totodata, aceasta functie imi intoarce prin efect lateral si marimea maxima a laturii unui bloc care nu a mai putut fi divizat. Dupa crearea arborelui am verificat numarul functionalitatii (c1 sau c2).

----------Functionalitate 1--------- 
Daca aveam functionalitatea 1 am calculat cu ajutorul a doua functii numarul de niveluri din arbore si numarul de frunze, pe care le-am afisat impreuna cu marimea maxima a laturii a unui bloc nedivizat returnata de functia anterioara.

---------Functionalitate 2----------
Pentru functionalitatea 2 am folosit o functie numita "PrintBin", cu ajutorul careia afisez imaginea comprimata. Functie foloseste o coada initializata la inceput cu radacina arborelui, punand ulterior celelalte noduri, pe care apoi le scoate, le scrie in fisierul de iesire si le retine in coada fii (in cazul in care nodul era unul intern), repetand acest proces pana cand toate nodurile din arbore au fost parcurse (coada devine vida).

----------Functionalitate 3----------
Pentru functionalitatea 3 folosesc o functie numita "DecIm" cu ajutorul careia transform un fisier rezultat din cerinta 2 intr-un arbore cuaternar. Functia foloseste un vector de structuri in care fii unui nod sunt pe pozitiile 4*poz_nod + k, k = {1, 2, 3, 4}. Dupa ce retin in vectorul de structuri alocat dinamic toate nodurile din fisierul de intrare, folosesc o coada asemanatoare cu cea folosita la cerinta a 2-a, in care introduc doar nodurile interne pe rand, scotandu-le la fiecare pas si lipindu-le fii, urmand ca fii de tip 0 sa fie introdusi in coada la randul lor. Aces proces continuand pana cand coada devine vida. La finalul functiei returnez arborele creat. Dupa aceea creez o matrice de culoare pe care o aloc dinamic, si cu ajutorul functiei "ConstrMat" creez matricea imaginii, asemanator cu construirea arborelui cuaternar de la inceputul programului. Astfel parcurg arborele si divizez matricea in cele 4 zone de fiecare data cand nodul curent este intern. Daca nodul este frunza atunci completez submatricea delimitata de indicii x, y, size, cu valorile culorilor din nod. Dupa ce am creat matricea imaginii afisez in fisier antetul acestui astfel incat sa fie o imagine ppm de tip P6 si incep afisarea imaginii, afisand cate o linie a matricei pe rand.
La finalul fiecarei cerinte dezaloc memoria folosita.

